{"./":{"url":"./","title":"内容简介","keywords":"","body":"内容简介 个人知识库。 © all right reserved，powered by Gitbookupdated: 2020-07-31 22:28:41 "},"lang/bash/summary.html":{"url":"lang/bash/summary.html","title":"bash","keywords":"","body":"Bash编程 linux基础 bash基础 正则表达式 awk入门 © all right reserved，powered by Gitbookupdated: 2020-09-10 23:21:20 "},"lang/bash/linux.html":{"url":"lang/bash/linux.html","title":"linux基础","keywords":"","body":" Linux基础 Date 格式化输出 按年月日时分秒的格式输出$ date \"+%Y-%m-%d %H:%M:%S\" 2019-12-02 11:16:52 © all right reserved，powered by Gitbookupdated: 2019-12-02 12:27:02 "},"lang/bash/basic.html":{"url":"lang/bash/basic.html","title":"bash基础","keywords":"","body":" Bash基础 语法 变量 表达式 函数 常见操作 字符串处理 字符串比较 字符串长度 通过变量表达式${#变量名} $ str1=\"abcde\" $ echo ${#str1} 5 提取子字符串 ${变量名:起始位置:长度} 提取从起始位置开始，指定长度的子字符串；不影响原变量 $ str=\"helloworld\" $ echo ${str:2:3} llo ${变量名#正则表达式} 删除变量头部匹配正则表达式的子串，匹配时是最短匹配；不影响原变量 $ fullpath='/tmp/test/aaa.txt' $ echo ${fullpath#/} # 删除变量开头的 / tmp/test/aaa.txt $ echo ${fullpath#/*} tmp/test/aaa.txt 如上面的例子所示，因为采用了最短匹配，所以/后面的星号没有起作用。 ${变量名%子字符串正则表达式} 删除变量尾部匹配正则表达式的子串，匹配时是最短匹配；不影响原变量 $ fullpath='/tmp/test/aaa.txt' $ echo ${fullpath%.txt} # 删除.txt后缀 /tmp/test/aaa $ echo ${fullpath%/*} # 删除变量尾部第一个/后面所有的内容，类似dirname的功能 /tmp/test $ echo ${fullpath%*} /tmp/test/aaa.txt 上面最后一个例子，星号是匹配0个、1个或多个任意字符，因为最短匹配，所以，这里不会匹配任何字符。 ${变量名##正则表达式} 删除变量头部匹配正则表达式的子串，匹配时是最短匹配；不影响原变量 $ fullpath='/tmp/test/aaa.txt' $ echo ${fullpath##/} # 删除变量开头的 / tmp/test/aaa.txt $ echo ${fullpath##/*aaa} # 删除变量开头的 / 与 aaa 之间所有的字符 .txt $ echo ${fullpath##/*} # 删除变量开头的 / 到行尾所有的字符 ##区别于#的地方就是采用最长匹配还是最短匹配。 ${变量名%%正则表达式} 删除变量尾部匹配正则表达式的子串，匹配时是最短匹配；不影响原变量 $ fullpath='/tmp/test/aaa.txt' $ echo ${fullpath%%/aaa.*} # 删除变量尾部匹配 /aaa.* 的子串 tmp/test/aaa.txt $ echo ${fullpath##/*} # 删除变量尾部匹配 /* 的子串 上面最后的例子中，因为/*匹配了所有内容，所以删除之后，就是空字符串了 字符串替换 ${变量/查找/替换值} 用替换值替换变量中匹配查找部分的字符串；不影响原变量； $ fullpath='/tmp/test/aaa/bbb/aaa.txt' $ echo ${fullpath/aaa/bbb} /tmp/test/bbb/bbb/aaa.txt $ echo ${fullpath/aaa/bbb/ccc} /tmp/test/bbb/ccc/bbb/aaa.txt $ echo ${fullpath/aaa/bbb/ccc/ddd} /tmp/test/bbb/ccc/ddd/bbb/aaa.txt 如上面的例子所示，变量的替换只会进行一次，只有第一个匹配的子串被替换。 join字符串 通过某个字符来连接一组字符串是一个非常常见的操作，join字符串一个非常便捷的方法就是临时改变IFS 具体如下： $ joinstr() { local IFS=$1; shift; echo \"$*\"; } $ joinstr / aa bb cc dd aa/bb/cc/dd 文件操作 参考文档 https://www.tldp.org/LDP/abs/html/string-manipulation.html © all right reserved，powered by Gitbookupdated: 2020-01-30 20:22:04 "},"lang/bash/regex.html":{"url":"lang/bash/regex.html","title":"正则表达式","keywords":"","body":" 正则表达式 基本使用方法 贪婪模式 懒惰模式 独占模式 调试工具 regex101 RegexBuddy 可能的问题 由于大部分语言的正则表达式都是基于回溯实现的，如果匹配时，回溯过多，可能造成CPU 100%，服务阻塞。 解决办法： 通过静态代码扫描或动态模糊测试发现潜在的正则表达式问题 采用非回溯实现的正则表达式引擎，如：re2、hyperscan、sregex； 参考文章： 如何彻底避免正则表达式的灾难性回溯？ © all right reserved，powered by Gitbookupdated: 2020-09-11 00:39:36 "},"lang/bash/awk.html":{"url":"lang/bash/awk.html","title":"awk入门","keywords":"","body":" awk基础 常见问题 带缓存输出 awk的print函数在输出时是先输出到buffer，这使得awk输出到标准输出时和输出到管道时表现不一样。例如： while true do clush -l root -g sql_px uptime sleep 1 done | awk '{printf(\"{\\\"load\\\":%f}\\n\",$NF)}' 通过上面的命令，可以持续的观察到sql_px这组服务器的15分钟的平均负载。 但是如果将命令的输出改为管道，如下所示： while true do clush -l root -g sql_px uptime sleep 1 done | awk '{printf(\"{\\\"load\\\":%f}\\n\",$NF)}' | jq 上面的命令将awk的输出作为jq的输入，通过jq来格式化输出，但这时候，好久都看不到任何输出。 经过一番查找，发现原来是awk的输出具有缓冲效果，也就是说awk的输出如果是管道，awk不会立即将内容输出到管道，而是缓存起来，积累到一定的量再输出，从而导致管道后续的没有没有拿到输入。 那有什么解决办法呢？我尝试了两种方法，最后都有效。 方法1：将awk的print函数的输出重定位到文件，然后通过tail读文件。具体如下： while true do clush -l root -g sql_px uptime sleep 1 done | awk '{printf(\"{\\\"load\\\":%f}\\n\",$NF) > \"bbb\"}' tail -f bbb | jq 上面的方法从实际测试效果看是没有问题的。不过原理上来说，还是有风险。 方法2：在print函数后面调用fflush，强制输出。具体如下： #!/bin/bash while true do clush -l root -g sql_px uptime sleep 1 done | awk '{printf(\"{\\\"load\\\":%f}\\n\",$NF); fflush(\"\")}' | jq 因为调用了fflush函数，所以，awk的输出会立即执行。这个方法相对稳妥。 © all right reserved，powered by Gitbookupdated: 2020-01-05 22:30:39 "},"lang/vim/summary.html":{"url":"lang/vim/summary.html","title":"vimscript","keywords":"","body":"vimscript编程 编程基础 编写插件 © all right reserved，powered by Gitbookupdated: 2020-09-21 12:29:48 "},"lang/vim/basic.html":{"url":"lang/vim/basic.html","title":"基础篇","keywords":"","body":" vim脚本基础 语法 变量 定义变量 通过let关键字来定义变量。 let定义变量的格式是let {变量名} = {表达式} 例如： \" 数字变量 let i = 1 \" 字符串变量 let s = \"hello,vimscript\" \" 列表变量 let fruits = [\"apple\", \"pear\"] 变量作用域 默认情况下，let定义的变量是全局变量。 由于vim的插件数量非常多，不同插件都定义全局变量的话，变量很容易冲突。 在vimscript中，可以通过给变量添加前缀，表明变量的作用范围。具体如下： 变量格式 作用域 v:varname vim预定义的变量 g:varname 全局变量；在任何地方都可以访问 l:varname 局部变量；在函数内部可以访问 s:varname 插件变量；在同一个插件内可以访问 b:varname 缓冲区变量：在定义的缓冲区内可以访问 w:varname 窗口变量：在定义的前窗口内可以访问 a:varname 函数变量：只能在函数内部使用在 特殊的变量 变量格式 含义 $varname 环境变量 &varname 选项值 @regname 寄存器 删除变量 通过unlet可以删除变量，并释放变量所占用的内存。 如果不确定变量是否存在，又不想看到变量不存在的提示信息，可以在unlet后面添加!，表示忽略错误。 表达式 表达式是编程语言的基础，vimscript也不例外。 表达式大致分为：逻辑运行、数字运算、字符串运算及其他运算。 常见的逻辑表达式如下： 格式 含义 {表达式1} == {表达式2} 等于 {表达式1} != {表达式2} 不等于 {表达式1} > {表达式2} 大于 {表达式1} >= {表达式2} 大于等于 {表达式1} 小于 {表达式1} 小于等于 算数运算 vimscript支持加减乘除、求余等运算。格式如下： 格式 含义 {表达式1} + {表达式2} 数值加法 {表达式1} - {表达式2} 数值减法 {表达式1} * {表达式2} 数值乘法 {表达式1} / {表达式2} 数值除法 {表达式1} % {表达式2} 数值求余 字符串运算 格式 含义 {字符串1} =~ {字符串2} 匹配正则表达式 {字符串1} != {字符串2} 不匹配正则表达式 {字符串1} ==? {字符串2} 等于，忽略大小写 {字符串1} . {字符串2} 连接两个字符串 与或非 格式 含义 {表达式1} && {表达式2} 逻辑与 {表达式1} \\ \\ {表达式2} 逻辑或 ! {表达式} 逻辑非 其他类型 格式 含义 {表达式1} ? {表达式2} : {表达式3} 如果表达式1为真，结果等于表达式2的值，否则为表达式3的值 {表达式1} is {表达式2} 相同的列表实例 {表达式1} isnot {表达式2} 不同的列表实例 逻辑控制 条件判断 if语句 单分支的判断语句的格式如下： if {表达式} {代码块} endif 双分支的判断语句的格式如下： if {表达式} {代码块1} else {代码块2} endif 多分支的判断语句的格式如下： if {表达式1} {代码块1} elseif {表达式2} {代码块2} else {代码块3} endif 循环语句 for语句的格式如下： for {var} in {list} {代码块} endfor while语句的格式如下： while {表达式} {代码块} endwhile 在for或while语句中，可能用到continue和break来做跳转。它们的含义如下： continue: 跳回for或while循环的开始，继续循环； break: 跳转到endfor或endwhile之后的命令，跳出循环； 执行表达式 vimscript中通过execute命令来执行单个表达式。 函数 内置函数 内置函数 作用 printf 格式化输出 echo 字符串输出 eval 将字符串作为表达式执行，获取执行后的结果 通过:help functions命令可以获取内置函数的信息。 自定义函数 自定义函数的格式如下： function FuncName(arg1, arg2, ...) [关键字] {代码块} endfunction 注意: 函数名必须以大写字母开头。定义函数时，如果在关键字后面添加!表示重新定义函数，如果前面定义了同名函数，则会把新的函数定义覆盖。 函数结尾的关键字对函数的行为也会有影响。下面看下range这个关键字。 通过call调用函数时，可以指定在那些行执行函数。如果函数定义时添加了range关键字，表示它会自行处理该范围。vim在调用改函数时，会给它传递两个参数： a:firstline和a:lastline，表示范围内的第一行和最后一行。例如： function Count_words() range let lnum = a:firstline let n = 0 while lnum 可以用如下的方式调用函数： :10,30call Count_word() 如上，这个函数将被调用一次并显示10到30行的总字数。 如果函数定义时，没有添加range关键字，那么vim会把光标移动到范围内的每一行，并分别对改行调用此函数。例如： function Number() echo \"line\" . line(\".\") . \"contains\" . getline(\".\") endfunction 如果用下面的方式调用该函数： :10,30call Number() 那么Number函数将被调用21次。 除了range关键字，abort也是经常会使用的关键字。abort表示函数执行到第一个错误时就退出。 通过:function命令可以获取所有自定义的函数。 可变参数 在定义函数时，vim允许你定义参数个数可变的函数（最多20个参数）。看下面的例子： function Show(start, ...) 使用可变参数时，有如下的预定义的变量： a:1 第一个可选参数；即start后的第一个参数； a:2 第二个可选参数；其他的以此类推，一直到a:20 a:0 表示可变参数的个数； a:000 表示所有...参数的列表。a:1相当于a:000[0] 看下面的例子：function Show(start, ...) echo \"start is \" . a:start let index = 1 while index 调用上面的函数，看下输出。:call Show(1, 2, 4, 6) start is 1 Arg 1 is 2 Arg 2 is 4 Arg 3 is 6 调用函数 函数可以被call命令调用，调用时，参数列表要用括号括起来，并用逗号分隔各个参数。 例如： call search(\"Date:\", \"w\") 删除函数 通过delfunction关键字可以删除自定义的函数。如果函数不存在，会看到一个提示信息。类似的，在delfunction后面添加!即可忽略错误信息。 函数引用 函数编程中经常需要把函数赋值给变量或定义匿名函数，vim同样也支持这种方式，通过function()来实现。看下面的例子： let result = 0 function! Right() return 'Right' endfunction function! Wrong() return 'Wrong' endfunction if result == 1 let Afunc = function('Right') else let Afunc = function('Wrong') endif echo call(Afunc, []) 上面的函数执行结果是Wrong。 注意： 保存函数引用的变量也需要大写字母开头；通过call()调用函数时，第一个参数是函数引用的变量名称，第二个参数是参数列表。 高级数据结构 与其他高级编程语言类型，vim也支持复杂的数据结构：列表和字典； 列表 定义列表 通过let关键字定义 \" 定义空列表 let alist = [] \" 定义字符串列表 let alist = [\"foo\", \"bar\"] \" 定义混合列表 let alist = [1, 2, \"foo\", \"bar\"] 通过range()定义 \" 单个参数: range(num)，返回0~num-1的整数列表 range(4) \" [0, 1, 2, 3] \" 两个参数：range(start, end), 返回start~end-1的整数列表； range(2, 4) \" [2, 3, 4] range(2, 0) \" error! \" 三个参数：range(start, end, step), 返回从start开始，步长为step，最大值小于end的整数列表 range(2, 9, 3) \" [2, 5, 8] range(2, -2, -1) \" [2, 1, 0, -1, -2] 遍历列表 通过for循环遍历 let alist = [\"one\", \"two\", \"three\"] for n in alist echo n endfor for i in range(1, 9) echo i endfor 列表操作 通过add()函数添加元素 let alist = ['one'] call add(alist, 'foo') \" alist = ['one', 'foo'] call add(alist, 'bar') \" alist = ['one', 'foo', 'bar'] 通过extend()或+合并列表 let alist = ['one'] call extend(alist, ['foo', 'bar']) \" alist = ['one', 'foo', 'bar'] let alist = alist + ['foo', 'bar'] \" alist = ['one', 'foo', 'bar'] add()和extend是有差别的，add()是给列表增加单个元素，extend()则是合并列表，两个参数都必须是列表或字典； 字典 字典定义 通过let定义字典 \" 定义空字典 let map1 = {} \" 定义键值对 let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'} 引用字典 \" 通过[]引用 echo uk2nl['one'] \" 通过.引用 echo uk2nl.one 字典操作 遍历字典 \" 通过keys函数获取所有索引 for key in keys(nk2nl) echo key endfor © all right reserved，powered by Gitbookupdated: 2020-09-21 12:23:42 "},"lang/vim/write-plugin.html":{"url":"lang/vim/write-plugin.html","title":"编写插件","keywords":"","body":" 编写vim插件 基础 插件加载顺序 © all right reserved，powered by Gitbookupdated: 2020-09-21 12:31:54 "},"os/macos/summary.html":{"url":"os/macos/summary.html","title":"MacOS","keywords":"","body":"MacOS操作系统 Tips © all right reserved，powered by Gitbookupdated: 2019-12-05 10:47:55 "},"os/macos/tips.html":{"url":"os/macos/tips.html","title":"Tips","keywords":"","body":" MacOS Tips 系统配置 禁止后台下载更新sudo defaults write /Library/Preferences/com.apple.SoftwareUpdate AutomaticDownload -boolean FALSE 软件配置 Java Home路径 在我的电脑上（mojave 10.14.6）安装了jre-8u211-macosx-x64.dmg，但是我命令行执行java -version的时候系统报错，说找不到java runtime。 No Java runtime present, requesting install. 用java_home找了一下，确实找不到： $ /usr/libexec/java_home -V Unable to find any JVMs matching version \"(null)\". Matching Java Virtual Machines (0): Default Java Virtual Machines (0): No Java runtime present, try --request to install. 在网上找了一番，是说，JRE可能在两个位置： /Library/Java/JavaVirtualMachines /Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents 于是分别在两个位置找了一下，发现果然在Internet Plug-Ins目录下，然后修改bash配置文件，添加如下的内容： export JAVA_HOME=\"/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home\" export PATH=$JAVA_HOME/bin:$PATH 然后重新source一下，再次执行java -version，结果就正常了。 安装xcode命令行工具 执行xcode-select --install安装命令行工具时报错，具体如下： $ xcode-select --install xcode-select: error: command line tools are already installed, use \"Software Update\" to install updates 解决方法：删除现有的老版本，然后重装一下。具体命令如下： $ sudo rm -fr /Library/Developer/CommandLineTools $ xcode-select --install 参考下面的链接：https://stackoverflow.com/questions/34617452/how-to-update-xcode-from-command-line 网络配置 给一块网卡添加多个IP地址 $ sudo ifconfig en0 alias 10.10.1.1 netmask 255.255.255.0 开启内核转发 $ sysctl -w net.inet.ip.forwarding=1 © all right reserved，powered by Gitbookupdated: 2020-10-24 15:34:27 "},"os/linux/summary.html":{"url":"os/linux/summary.html","title":"Linux","keywords":"","body":"Linux操作系统 内核工作原理 性能调优 常用工具 © all right reserved，powered by Gitbookupdated: 2020-01-29 21:18:03 "},"os/linux/kernel.html":{"url":"os/linux/kernel.html","title":"内核简介","keywords":"","body":" 内核工作原理 进程调度 进程的概念 进程调度算法 进程的组织方式 内存管理 buddy算法 slab算法 文件管理 网络协议栈 Conntrack conntrack(连接跟踪)是linux内核协议栈一个核心的特性，它允许内核跟踪每个逻辑的网络连接，并通过一致的方式处理网络连接的每个数据包。 conntrack是linux内核有状态防火墙和NAT的基础。 conntrack的限制 conntrack是通过一张表格来记录所有的连接的信息，一旦表满了，通常情况下，新的网络连接会被拒绝或丢弃。 下面几种情况下，conntrack可能遇到问题： 服务器需要同时处理大量并发的连接；比如，conntrack连接记录表有128K，但是服务器需要同时处理大于128K个网络连接； 另一种情形是，服务器需要处理大量的短连接（比如，20秒内处理了128K个新的网络连）即使是短连接，内核默认会保持连接信息120秒，而不是连接断开后立即释放。如果conntrack连接记录表是128K，那么服务器每秒钟最多处理128k/120=1092个连接。如果短连接的数量多于每秒1092个，就会出现建立不了连接的问题。 通常情况下，通过增加conntrack表项的数量，缩短跟踪时间，可以解决大部分问题。但是在一些情况下，可能需要考虑跳过conntrack模块。 https://www.projectcalico.org/when-linux-conntrack-is-no-longer-your-friend/ © all right reserved，powered by Gitbookupdated: 2020-09-17 23:11:57 "},"os/linux/perf.html":{"url":"os/linux/perf.html","title":"性能调优","keywords":"","body":" 性能调优 CPU性能 平均负载 平均负载的概念 系统平均负载指的是一段时间内处于可运行状态（Running 或 Runnable）和不可中断状态（Uninterruptible）的进程数的平均值。 可运行状态的进程可能是CPU正在运行的进程，也可能是随时可以被调度执行的程序。 不可中断状态的进程通常是进程在与外部设备交互，为了保证交互的正常进行，交互过程不能被打断，因而处于不可中断状态； 该状态下，进程不会接收和处理信号（signal），即使是kill -9和kill -15也不能杀死该状态的进程。 系统平均负载不同于CPU利用率，CPU利用率指的是某个时间，CPU的繁忙与空闲程度。对于I/O密集型的应用，可能出现平均负载很高， 但是CPU利用率却不高的情况，因为I/O密集型的应用，可能很多进程因为在等待外部设备的响应而处于不可中断状态，这时候CPU 并没有多少进程可执行，因此，CPU利用率不高。 有三种情况可能导致系统平均负载升高： CPU密集型的应用：应用本身有大量的计算要执行，执行的过程中，需要不断的占用CPU资源； I/O密集型的应用：应用需要和外部设备进行大量的交互，导致进程处于不可中断状态，此时系统负载高，但是CPU利用率可能较低； 混合型的应用：系统中有大量处于可运行状态的进程，因为进程的调度和频繁的切换也会消耗大量的CPU资源； 查看平均负载 查看系统平均负载 # 查看系统最近1、5、15分钟的平均负载 $ uptime 07:43:20 up 2:32, 3 users, load average: 0.00, 0.00, 0.26 uptime输出的最后三个数就代表系统最近1分钟、5分钟、15分钟的平均负载。 查看每个CPU的利用率 对于多核的系统，mpstat可以方便的查看所有CPU的利用率。具体如下： # 以5秒的间隔显示所有CPU的利用率 # mpstat -P ALL 5 Linux 4.15.0-65-generic (perf1) 01/29/2020 _x86_64_ (2 CPU) 01:02:28 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 01:02:33 PM all 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 01:02:33 PM 0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 01:02:33 PM 1 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 ^C Average: CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle Average: all 0.00 0.00 0.03 0.00 0.00 0.00 0.00 0.00 0.00 99.97 Average: 0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 Average: 1 0.00 0.00 0.07 0.00 0.00 0.00 0.00 0.00 0.00 99.93 mpstat输出的CPU利用率各个字段的含义如下： CPU：all表示所有CPU的总体统计情况，数字是CPU核的编号（从0开始），表示单个核的统计情况； %usr：表示CPU处于用户态的时间比例； %nice：表示CPU处于用户态且由于nice优先权的时间比例； %sys：表示CPU处于内核态的时间比例； %iowait：表示CPU因为等待I/O而空闲的时间比例； %irq：表示CPU处理硬件中断的时间比例； %soft：表示CPU处理软中断的时间比例； %steal：在虚拟化情况下，表示因为等待hypervisor而非自愿等待的时间占比； %guest：在虚拟化情况下，表示CPU处于虚拟化状态的时间占比； %gnice：在虚拟化情况下，表示CPU处于niced虚拟化状态的时间占比； %idle：表示CPU处于空闲状态的时间比例； 查看近期占用CPU较多的进程 mpstat输出的是单个或所有CPU的统计信息，在排查性能问题时，肯定需要具体到某个进程， 因此，获得近期占用CPU最多的进程的工具十分有必要。pidstat就是这样的一个工具。 # 显示最近5秒钟占用CPU最多的进程 # pidstat -u 5 1 Linux 4.15.0-65-generic (perf1) 01/29/2020 _x86_64_ (2 CPU) 01:36:23 PM UID PID %usr %system %guest %wait %CPU CPU Command 01:36:28 PM 0 20457 0.20 0.20 0.00 0.00 0.40 0 top 01:36:28 PM 0 20465 0.00 0.20 0.00 0.00 0.20 1 pidstat Average: UID PID %usr %system %guest %wait %CPU CPU Command Average: 0 20457 0.20 0.20 0.00 0.00 0.40 - top Average: 0 20465 0.00 0.20 0.00 0.00 0.20 - pidstat pidstat输出的近期CPU利用率各字段的含义如下： UID：启动进程的用户的ID PID：进程的ID %usr：进程处于用户态（不包括处于虚拟化状态）的时间占比； %system：进程处于内核态的时间占比； %guest：进程处于虚拟化模式的时间占比； %wait：进程处于等待执行状态的时间占比； %CPU：进程总的CPU利用率； CPU：运行进程的CPU核心的编号 内存性能 I/O性能 网络性能 © all right reserved，powered by Gitbookupdated: 2020-01-29 21:46:23 "},"os/linux/tools.html":{"url":"os/linux/tools.html","title":"常用工具","keywords":"","body":" Linux常用工具 网络相关 nmap 发现局域网中有哪些机器： 1. ARP 扫描 nmap -sn -PR 10.1.1.0/24 探测主机开放端口： 1. TCP SYN Ping nmap -sn -PS 10.1.1.2 2. TCP ACK Ping nmap -sn -PA 10.1.1.2 tc trickle 限速原理 pv tcpdump 抓取LVS tunnel隧道的包tcpdump -nn -i eth0 'ip[9]==4' © all right reserved，powered by Gitbookupdated: 2020-09-04 12:47:41 "},"cloud/summary.html":{"url":"cloud/summary.html","title":"云计算","keywords":"","body":" 云领域相关知识 openstack kubernetes © all right reserved，powered by Gitbookupdated: 2020-11-26 16:45:41 "},"cloud/ceph/summary.html":{"url":"cloud/ceph/summary.html","title":"ceph存储","keywords":"","body":" ceph分布式存储系统剖析 存储的基本概念 分布式存储 分布式存储指的是利用服务器的直连磁盘搭建的，具有灵活、高可扩展、高可用、高性能等特征的存储系统。 从功能上讲，分布式存储系统与集中式存储类似；从设备投入和成本的角度来讲，分布式存储系统通过普通的商用服务器和网络设备即可搭建， 不需要专用的硬件设备，价格更加低廉；通过冗余及分布式技术，保证存储的高可用和高性能。 块存储 块存储相当于传统SAN存储的一个LUN，包含了一定的容量限制，通过iSCSI或FC-SCSI协议进行连接和使用，非常接近于生活中常用的移动硬盘。 为了使用块存储，首先需要将块存储连接到服务器（可以是虚拟机），然后进入服务器，对其划分磁盘分区，执行格式化，最后挂载到某个目录，才能使用。 对象存储 对象存储与常见的存储有较大的差别，通过HTTP协议进行访问的；它没有目录的概念，是通过对象的名称区别不同的文件；保存的数据通常是读多写少。 文件存储 文件存储指的是类似于NFS的存储系统，为使用文件存储，首先需要通过网络挂载到服务器的某个目录，然后应用程序可以通过posix协议对文件进行操作。 ceph架构分析 ceph是近些年非常受欢迎的开源分布式存储系统，在很多行业和领域都有着广泛的应用；基于openstack的云平台基本上都把ceph作为默认的存储系统。 ceph从功能上能够同时提供：块存储、对象存储、文件存储。ceph总体架构如下图所示： 如上图所示，ceph存储最底层的是RADOS（Reliable Autonomic Distributed Object Store），块存储、对象存储、文件存储都是基于RADOS构建起来的。 RAODS RADOS是一个PB级别、自动、弹性可伸缩的对象存储系统。它具有如下特点： 它有存储节点（osd）和控制节点（monitor）组成 数据的同步、备份、更新、迁移、恢复都是动态进行的 通过CRUSH算法保证一个数据的多个副本调度到不同的存储节点上 每个存储节点都有全局的每个对象存储到哪个节点上是通过计算得出的 在ceph存储系统中，一切皆对象。上层的块存储、对象存储、文件存储的对象按照固定大小切分成小的对象，然后存储到RADOS中。具体过程如下： 如上图所示，块存储、对象存储、文件存储按固定大小切分成小的对象后，并不是直接映射到具体的OSD上，而是要经过一个中间层：PG（place group）；PG再经过CRUSH算法映射到具体的磁盘上。此外，ceph还有一个pool的概念，ceph可以将整个集群划分成若干个pool，每个pool设置一定数量的PG，每个PG只能属于一个pool。pgid的格式是：pool_id.pg_id。 ceph monitor ceph monitor提供kv存储，用来保存集群关键的状态数据，同时还负责监控各个存储节点的状态。ceph monitor的总体架构如下图所示： 如上图所示，ceph monitor存储了如下的状态数据(Cluster Map)： monitor map：包含了集群的全局信息：fsid、epoch及所有monitor的地址和状态；通过ceph mon dump查看； osd map：包含了集群的fsid、epoch、pool列表及所有osd的连接地址信息；通过ceph osd dump查看； pg map：包含了集群所有pg的状态、版本、最小的osd epoch、每个pg的up set和acting set等；通过ceph pg dump查看； crush map：包含了所有存储设备及其组织信息（如：机房、机柜、服务器等）及存储设备的选择算法；通过ceph osd getcrushmap -o 命令获取，然后通过crushtools -d -o 进行解码； mds map：包含了mds信息的epoch、创建时间、最后更新时间、存储元数据的pool名称及mds服务器列表及相关服务器的状态；通过ceph fs dump查看； 客户端启动后，首先会和ceph monitor通信，获取集群当前的状态信息（Cluster Map：monitor map、osd map、pg map、crush map、mds map等），随后通过对象名称及存储池的信息，可以计算出pg信息，再根据pg map可以获取到osd列表，通过osd map可以获取osd连接信息，然后客户的就可以和osd进行通信，进行数据的读写了。 ceph osd ceph pg ceph心跳机制 数据重平衡 CRUSH算法 CRUSH算法核心的目标是将PG映射到一组OSD，同时实现如下目标： 数据需要保存多个副本，算法需要选择出指定数量的OSD 选择OSD时，需要考虑数据容灾的需求，比如：选出来的多个OSD不能来自于同一台服务器 各个OSD的磁盘使用率尽可能均衡 OSD出现故障时，保持最小化数据迁移成本 CRUSH算法通过树状形式来组织OSD及OSD关联的信息（如：所属的服务器、所在的机柜及数据中心）。如下图： 如上图，CRUSH算法选择OSD时，是从树的根root开始的，根据算法的定义遍历bucket（上图中的host foo及host bar），bucket可以有多个层级，可以根据实际情况进行调整。最后从叶子节点（也就是OSD节点）中选择具体的OSD。 RULE 下面看个具体的例子，如下： rule replicated_ruleset { id 0 type replicated min_size 1 max_size 10 step take default step chooseleaf firstn 0 type host step emit } 如上，每条rule都需要明确一些核心的参数： type：replicated，表明这条规则只适用于多副本的存储池 min_size: 1 表示多副本的情况下，最小只有一个副本即可提供服务，3副本的情况下，建议设置为2 max_size: 10 表示多副本的情况下，最大可以保存10个副本 step xxx: step是指明选择OSD时需要执行的具体步骤；step里面至少需要有一条chooseleaf指令和emit指令； OSD的信息是通过树状结构进行组织的，就有很大的灵活性。根据实际需要可以实现跨机柜、跨机房的冗余。更复杂的例子可以参考下面的文章： http://cephnotes.ksperis.com/blog/2015/02/02/crushmap-example-of-a-hierarchical-cluster-map/ 关于CRUSH算法本身的实现可以参考： http://www.xuxiaopang.com/2016/11/08/easy-ceph-CRUSH/ 参考资料 https://zhuanlan.zhihu.com/p/58888246 思考 ceph monitor上需要保存什么信息？ OSD down了之后，pg发生remap之后，client端如何发现，需要怎么处理？ 认证机制 容灾架构 ceph常见运维操作 添加/删除/修改pool 添加/删除/修改osd 添加/删除/修改mon 添加/删除/修改rgw 调整crushmap 获取 CRUSH 图 要获取集群的 CRUSH 图，执行命令： ceph osd getcrushmap -o {compiled-crushmap-filename} Ceph将把 CRUSH 输出（ -o ）到你指定的文件，由于 CRUSH 图是已编译的，所以编辑前必须先反编译。 反编译 CRUSH 图 要反编译 CRUSH 图，执行命令： crushtool -d {compiled-crushmap-filename} -o {decompiled-crushmap-filename} Ceph将反编译（ -d ）二进制 CRUSH 图，且输出（ -o ）到你指定的文件。 反编译之后，就可以通过文本编辑器进行调整。调整完成后，需要编译并导入集群。 编译 CRUSH 图 要编译 CRUSH 图，执行命令： crushtool -c {decompiled-crush-map-filename} -o {compiled-crush-map-filename} Ceph 将把已编译的 CRUSH 图保存到你指定的文件。 导入 CRUSH 图 要把 CRUSH 图应用到集群，执行命令： ceph osd setcrushmap -i {compiled-crushmap-filename} Ceph 将把你指定的已编译 CRUSH 图输入到集群。 ceph性能优化 ceph监控 ceph最佳实践 参考文档 https://docs.ceph.com/en/latest/rados/operations/crush-map/ https://ceph.com/wp-content/uploads/2016/08/weil-rados-pdsw07.pdf © all right reserved，powered by Gitbookupdated: 2020-12-14 15:33:32 "},"db/summary.html":{"url":"db/summary.html","title":"数据库","keywords":"","body":"数据库 基础 © all right reserved，powered by Gitbookupdated: 2020-02-28 20:23:54 "},"db/common.html":{"url":"db/common.html","title":"基础","keywords":"","body":"分库分表常见问题 非拆分因子访问数据 数据倾斜 跨库事务 全局序列避重 © all right reserved，powered by Gitbookupdated: 2020-02-29 02:38:30 "},"ops/summary.html":{"url":"ops/summary.html","title":"技术运营","keywords":"","body":" 运维和运营 巡检 监控 基础监控 CPU 内存 磁盘 网络 服务监控 进程与端口 内部状态 业务监控 吞吐量 时延 错误率 同比/环比 应急处理 应急流程 应急处理方案 应急演练 © all right reserved，powered by Gitbookupdated: 2020-07-31 22:21:33 "},"arch/summary.html":{"url":"arch/summary.html","title":"架构分析","keywords":"","body":"架构分析 Redis © all right reserved，powered by Gitbookupdated: 2020-07-31 22:30:21 "}}